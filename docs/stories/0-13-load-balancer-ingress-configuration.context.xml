<story-context id="bmad/bmm/workflows/4-implementation/story-context" v="1.0">
  <metadata>
    <epicId>0</epicId>
    <storyId>13</storyId>
    <title>Load Balancer and Ingress Configuration</title>
    <status>ready-for-dev</status>
    <generatedAt>2026-02-09</generatedAt>
    <multiCloudNote>Context regenerated for multi-cloud (AWS + Azure) Two Roots architecture</multiCloudNote>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/0-13-load-balancer-ingress-configuration.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>DevOps Engineer</asA>
    <iWant>to configure load balancing and ingress with SSL termination</iWant>
    <soThat>external traffic reaches our applications securely with proper routing and rate limiting</soThat>
    <tasks>
      <task id="1" name="Ingress Controller Installation" acs="1,6">
        <subtask>1.1-1.5 Install NGINX Ingress Controller via Helm with replicas and health checks</subtask>
      </task>
      <task id="2" name="SSL/TLS Certificate Management" acs="4,5">
        <subtask>2.1-2.5 Install cert-manager, create ClusterIssuers, configure auto-renewal</subtask>
      </task>
      <task id="3" name="DNS Configuration" acs="2,3">
        <subtask>3.1-3.5 Create DNS zone (Route 53 / Azure DNS) records for app, api, staging domains</subtask>
      </task>
      <task id="4" name="Ingress Resources" acs="2,3,5">
        <subtask>4.1-4.5 Create Ingress resources for staging and production with routing</subtask>
      </task>
      <task id="5" name="Rate Limiting and Security" acs="7,8">
        <subtask>5.1-5.5 Configure rate limiting annotations, DDoS protection (AWS Shield / Azure DDoS), test limits</subtask>
      </task>
      <task id="6" name="Error Pages and Documentation" acs="9,10">
        <subtask>6.1-6.5 Create custom error pages, document configuration</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">NGINX Ingress Controller (cloud-agnostic) installed</ac>
    <ac id="2">Ingress routes traffic: app.qualisys.io to web, api.qualisys.io to api</ac>
    <ac id="3">Staging domain configured: staging.qualisys.dev</ac>
    <ac id="4">SSL certificates provisioned via cert-manager (Let's Encrypt)</ac>
    <ac id="5">HTTPS enforced with HTTP to HTTPS redirect</ac>
    <ac id="6">Health checks configured for backend services</ac>
    <ac id="7">Rate limiting configured (1000 req/min per IP)</ac>
    <ac id="8">DDoS protection enabled (AWS Shield / Azure DDoS Protection / Cloudflare)</ac>
    <ac id="9">Custom error pages configured (502, 503, 504)</ac>
    <ac id="10">Ingress annotations documented for team reference</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-specs/tech-spec-epic-0.md</path>
        <title>Epic 0 Technical Specification</title>
        <section>Services and Modules</section>
        <snippet>Load Balancer: Cloud LB (AWS ALB / Azure LB) + NGINX Ingress. SSL termination, rate limiting (1000 req/min). External traffic routing, HTTPS enforcement.</snippet>
      </doc>
      <doc>
        <path>docs/tech-specs/tech-spec-epic-0.md</path>
        <title>Epic 0 Technical Specification</title>
        <section>Security</section>
        <snippet>In transit: TLS 1.3 for load balancer. HTTPS enforced. Rate limiting at ingress level. DDoS protection via AWS Shield / Azure DDoS Protection.</snippet>
      </doc>
      <doc>
        <path>docs/epics/epic-0-infrastructure.md</path>
        <title>Epic 0: Infrastructure Foundation</title>
        <section>Story 0.13</section>
        <snippet>Load Balancer and Ingress Configuration: NGINX Ingress (cloud-agnostic), SSL certificates, HTTPS redirect, rate limiting, DDoS protection (AWS Shield / Azure DDoS), custom error pages.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/architecture.md</path>
        <title>System Architecture</title>
        <section>Networking</section>
        <snippet>Ingress controller handles external traffic routing. SSL termination at load balancer. Rate limiting protects against abuse. Health checks ensure traffic routes to healthy pods only.</snippet>
      </doc>
      <doc>
        <path>docs/stories/0-3-kubernetes-cluster-provisioning.md</path>
        <title>Story 0.3: Kubernetes Cluster Provisioning</title>
        <section>Ingress Controller</section>
        <snippet>Prerequisite: Kubernetes cluster (EKS/AKS) with ingress-nginx namespace. Ingress controller installed as part of cluster setup or this story.</snippet>
      </doc>
    </docs>

    <code>
      <note>Ingress infrastructure - Story 0.2 (VPC) and 0.3 (Kubernetes) provide foundation.</note>
      <prerequisites>
        <story id="0-2-vpc-network-configuration" status="ready-for-dev">
          <provides>Public subnets for load balancer, security groups</provides>
        </story>
        <story id="0-3-kubernetes-cluster-provisioning" status="ready-for-dev">
          <provides>Kubernetes cluster (EKS/AKS), namespaces for ingress controller deployment</provides>
        </story>
      </prerequisites>
      <expectedStructure>
        <folder path="kubernetes/ingress-nginx" purpose="NGINX Ingress Controller configuration" />
        <file path="kubernetes/ingress-nginx/values.yaml" purpose="Helm values for ingress controller" />
        <file path="kubernetes/ingress-nginx/custom-error-pages.yaml" purpose="Custom error page ConfigMap" />
        <folder path="kubernetes/cert-manager" purpose="cert-manager configuration" />
        <file path="kubernetes/cert-manager/cluster-issuer.yaml" purpose="Let's Encrypt ClusterIssuers" />
        <file path="kubernetes/staging/ingress.yaml" purpose="Staging ingress resource" />
        <file path="kubernetes/production/ingress.yaml" purpose="Production ingress resource" />
        <file path="terraform/dns.tf" purpose="DNS configuration (Route 53 / Azure DNS)" />
        <file path="CONTRIBUTING.md" purpose="Updated with ingress documentation" />
      </expectedStructure>
      <outputs description="Ingress and load balancing infrastructure">
        <output name="NGINX Ingress Controller" consumers="All external traffic" />
        <output name="SSL certificates" consumers="HTTPS termination" />
        <output name="DNS records" consumers="Domain resolution" />
        <output name="Ingress resources" consumers="Story 0.11, 0.12 deployments" />
      </outputs>
      <helmInstallCommands>
        <![CDATA[
# NGINX Ingress Controller
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install ingress-nginx ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --create-namespace \
  --set controller.replicaCount=2 \
  --set controller.resources.requests.cpu=100m \
  --set controller.resources.requests.memory=128Mi \
  --set controller.service.type=LoadBalancer \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb  # AWS; for Azure use: service.beta.kubernetes.io/azure-load-balancer-internal: "false"

# cert-manager
helm repo add jetstack https://charts.jetstack.io
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --set installCRDs=true
        ]]>
      </helmInstallCommands>
      <clusterIssuerTemplate>
        <![CDATA[
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: devops@qualisys.io
    privateKeySecretRef:
      name: letsencrypt-prod-key
    solvers:
      - http01:
          ingress:
            class: nginx
        ]]>
      </clusterIssuerTemplate>
      <ingressTemplate>
        <![CDATA[
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: qualisys-ingress
  namespace: production
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/limit-rps: "17"
    nginx.ingress.kubernetes.io/limit-connections: "10"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-XSS-Protection "1; mode=block" always;
spec:
  tls:
    - hosts:
        - app.qualisys.io
        - api.qualisys.io
      secretName: qualisys-production-tls
  rules:
    - host: app.qualisys.io
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: qualisys-web-stable
                port:
                  number: 3000
    - host: api.qualisys.io
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: qualisys-api-stable
                port:
                  number: 3000
        ]]>
      </ingressTemplate>
      <customErrorPagesTemplate>
        <![CDATA[
apiVersion: v1
kind: ConfigMap
metadata:
  name: custom-error-pages
  namespace: ingress-nginx
data:
  502.html: |
    <!DOCTYPE html>
    <html>
    <head><title>QUALISYS - Service Temporarily Unavailable</title></head>
    <body style="font-family: sans-serif; text-align: center; padding: 50px;">
      <h1>Service Temporarily Unavailable</h1>
      <p>We're performing maintenance. Please try again shortly.</p>
    </body>
    </html>
  503.html: |
    <!DOCTYPE html>
    <html>
    <head><title>QUALISYS - Service Unavailable</title></head>
    <body style="font-family: sans-serif; text-align: center; padding: 50px;">
      <h1>Service Unavailable</h1>
      <p>Please try again later.</p>
    </body>
    </html>
        ]]>
      </customErrorPagesTemplate>
      <dnsConfig>
        <![CDATA[
# terraform/dns.tf (AWS - Route 53)
resource "aws_route53_record" "app" {
  zone_id = aws_route53_zone.qualisys_io.zone_id
  name    = "app.qualisys.io"
  type    = "A"
  alias {
    name                   = data.aws_lb.ingress.dns_name
    zone_id                = data.aws_lb.ingress.zone_id
    evaluate_target_health = true
  }
}

resource "aws_route53_record" "api" {
  zone_id = aws_route53_zone.qualisys_io.zone_id
  name    = "api.qualisys.io"
  type    = "A"
  alias {
    name                   = data.aws_lb.ingress.dns_name
    zone_id                = data.aws_lb.ingress.zone_id
    evaluate_target_health = true
  }
}

# terraform/dns.tf (Azure - Azure DNS alternative)
# resource "azurerm_dns_a_record" "app" {
#   name                = "app"
#   zone_name           = azurerm_dns_zone.qualisys_io.name
#   resource_group_name = azurerm_resource_group.dns.name
#   ttl                 = 300
#   target_resource_id  = azurerm_public_ip.ingress.id
# }
#
# resource "azurerm_dns_a_record" "api" {
#   name                = "api"
#   zone_name           = azurerm_dns_zone.qualisys_io.name
#   resource_group_name = azurerm_resource_group.dns.name
#   ttl                 = 300
#   target_resource_id  = azurerm_public_ip.ingress.id
# }
        ]]>
      </dnsConfig>
    </code>

    <dependencies>
      <helm>
        <chart name="ingress-nginx/ingress-nginx" version="4.x" purpose="NGINX Ingress Controller" />
        <chart name="jetstack/cert-manager" version="1.x" purpose="Certificate management" />
      </helm>
      <kubernetes>
        <resource name="Ingress" purpose="Traffic routing rules" />
        <resource name="ClusterIssuer" purpose="Let's Encrypt certificate issuance" />
        <resource name="Certificate" purpose="TLS certificates" />
        <resource name="ConfigMap" purpose="Custom error pages" />
        <resource name="Service (LoadBalancer)" purpose="External load balancer" />
      </kubernetes>
      <cloud>
        <service name="Route 53 / Azure DNS" purpose="DNS management" />
        <service name="Network Load Balancer / Azure Load Balancer" purpose="Layer 4 load balancing" />
        <service name="AWS Shield Standard / Azure DDoS Protection" purpose="DDoS protection (automatic)" />
      </cloud>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint source="Security" critical="true">HTTPS enforced for all external traffic</constraint>
    <constraint source="Security" critical="true">Rate limiting prevents abuse (1000 req/min per IP)</constraint>
    <constraint source="Security">Security headers configured (X-Frame-Options, CSP, etc.)</constraint>
    <constraint source="Availability">Ingress controller runs with 2+ replicas for HA</constraint>
    <constraint source="Availability">Health checks ensure traffic routes to healthy pods only</constraint>
    <constraint source="Operations">Certificates auto-renew before expiration</constraint>
    <constraint source="Dependency">Story 0.2 (VPC) and 0.3 (Kubernetes) must be complete</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>NGINX Ingress Controller</name>
      <kind>Kubernetes controller</kind>
      <signature>Watches Ingress resources, configures NGINX for routing</signature>
      <path>kubernetes/ingress-nginx/</path>
    </interface>
    <interface>
      <name>cert-manager</name>
      <kind>Kubernetes controller</kind>
      <signature>Watches Certificate resources, provisions from Let's Encrypt</signature>
      <path>kubernetes/cert-manager/</path>
    </interface>
    <interface>
      <name>Let's Encrypt ACME API</name>
      <kind>REST API</kind>
      <signature>HTTP-01 challenge for domain validation</signature>
      <path>External service</path>
    </interface>
    <interface>
      <name>DNS API (Route 53 / Azure DNS)</name>
      <kind>Cloud API</kind>
      <signature>DNS record management via Terraform (provider-specific)</signature>
      <path>terraform/dns.tf</path>
    </interface>
    <interface>
      <name>Ingress Metrics</name>
      <kind>Prometheus metrics</kind>
      <signature>:10254/metrics exposes nginx_ingress_controller_* metrics</signature>
      <path>Prometheus ServiceMonitor</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Ingress testing validates controller installation, SSL certificate provisioning, routing rules, rate limiting, and error pages. DevOps Lead verifies configuration. Integration test performs end-to-end traffic routing verification.
    </standards>
    <locations>
      <location>kubectl commands for controller and ingress verification</location>
      <location>Browser for SSL and routing verification</location>
      <location>curl commands for rate limiting and redirect testing</location>
      <location>Cloud console (AWS Console / Azure Portal) for DNS and DDoS protection verification</location>
    </locations>
    <ideas>
      <idea ac="1">kubectl get pods -n ingress-nginx shows 2 running controller pods</idea>
      <idea ac="2">curl -H "Host: app.qualisys.io" http://INGRESS_IP returns web app content</idea>
      <idea ac="2">curl -H "Host: api.qualisys.io" http://INGRESS_IP/health returns API health</idea>
      <idea ac="3">curl https://staging.qualisys.dev returns staging application</idea>
      <idea ac="4">kubectl get certificates shows Ready=True for all domains</idea>
      <idea ac="4">openssl s_client -connect app.qualisys.io:443 shows valid Let's Encrypt cert</idea>
      <idea ac="5">curl -I http://app.qualisys.io returns 301 redirect to HTTPS</idea>
      <idea ac="6">kubectl describe ingress shows backend health status</idea>
      <idea ac="7">hey -n 2000 -q 50 https://api.qualisys.io/health shows 429 after limit</idea>
      <idea ac="8">Cloud console shows DDoS protection (AWS Shield Standard / Azure DDoS Protection) active for load balancer</idea>
      <idea ac="9">Stop all backend pods, curl returns custom 503 page</idea>
      <idea ac="10">CONTRIBUTING.md includes ingress annotation reference</idea>
      <idea ac="renewal">Wait for certificate to approach expiry, verify auto-renewal</idea>
      <idea ac="headers">curl -I https://app.qualisys.io shows security headers</idea>
    </ideas>
  </tests>
</story-context>
